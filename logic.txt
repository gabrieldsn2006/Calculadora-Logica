# 1. INPUT
-> válidos:
    - variáveis (letras)
    - operadores
    - valores lógicos (V/F)
    - parentesis
-> script:
    addComponent(value) {
        if (value is valid) add in expression
    }

# 2.1 SINTAXE
-> válidar parentesis, operações, variáveis que de fato formam uma expressão
-> exemplos válidos:
    (A → B) ∧ (B → A)
    ∼(A → (B ∧ C))
    (A → B)
    ∼A
-> exemplos inválidos:
    A)) ∧∧ → BC
    (A → ) B
    A ∨
-> script:
    isValid(expression) { return boolean }

# 2.2 ARVORE DA EXPRESSÃO
-> podemos ler a expressão como uma arvore binária. cada operação tem um valor a esquerda e um valor a direita. o valor de algum dos lados pode ser outra operação e por aí vai. a ideia é encontrar uma relação de que operação realizar primeiro (operações entre parentesis por exemplo) e qual realizar por último (raiz da arvore). a raiz deve ser a operação de escopo mais externo. em caso de mesmo escopo as operações são realizadas na ordem (primeira -> ultima): ~, ∨/∧, →/↔
-> encontrada a raiz (ultima operação a ser realizada) definimos então como contruir a arvore a partir de nós.
-> scritp:
    Node {
        String value; // (op)
        Node left;
        Node right;
    }
    findRoot(expression) { retorna o index da raiz }
    buildTree(rootIndex) { instância e retorna o Node da raiz }

# 3. RESOLVENDO
-> atribuir valores as variáveis e solucionar a expressão.
-> tabela-verdade: loop atribuindo valores as variáeis e construindo uma matriz para a tabela.
-> análise da tabela, definir tautologia, contradição etc.
-> script:
    solve(tree, entries) { return boolean }
    truthTable(expression) { isValid + findRoot + buildTree + solve loop + console.log }